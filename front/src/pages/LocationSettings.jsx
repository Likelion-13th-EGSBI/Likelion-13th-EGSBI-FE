// src/pages/LocationSettings.jsx
import React, { useEffect, useRef, useState, useCallback } from "react";
import Layout from "../components/Layout";
import BottomBar from "../components/BottomBar";
import "../css/location-settings.css";

/* ===============================
   ‚úÖ API & Auth Ïú†Ìã∏
   =============================== */
const BASE_URL = "https://likelion-att.o-r.kr/v1";

// Î°úÏª¨Ïä§ÌÜ†Î¶¨ÏßÄ ÌÇ§(Îëê ÌòïÌÉú Î™®Îëê ÏßÄÏõê)
function getAccessToken() {
  return localStorage.getItem("Token") || localStorage.getItem("accessToken") || "";
}
function getUserId() {
  const v = localStorage.getItem("userid") ?? localStorage.getItem("userId");
  return v ? Number(v) : null;
}
function getEmail() {
  return localStorage.getItem("userEmail") || localStorage.getItem("email") || "";
}

async function ensureIdentity() {
  return { userId: getUserId(), email: getEmail(), accessToken: getAccessToken() };
}

// Í≥µÌÜµ fetch(JSON/ÌÖçÏä§Ìä∏)
async function fetchJson(url, options = {}) {
  const res = await fetch(url, options);
  const ct = res.headers.get("content-type") || "";
  const isJson = ct.includes("application/json");
  const body = isJson ? await res.json().catch(() => null) : await res.text().catch(() => null);

  if (!res.ok) {
    const msg = (isJson && (body?.message || body?.error)) || body || `HTTP ${res.status}`;
    const err = new Error(String(msg));
    err.status = res.status;
    err.body = body;
    throw err;
  }
  return body;
}

// GET /user/location/{id}
async function apiGetUserLocationById(userId) {
  const token = getAccessToken();
  const url = `${BASE_URL}/user/location/${userId}`;
  return fetchJson(url, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
}

// POST /user/location  (body: {email, latitude, longitude, address})
async function apiSaveUserLocation({ email, latitude, longitude, address }) {
  const token = getAccessToken();
  const url = `${BASE_URL}/user/location`;
  return fetchJson(url, {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
    body: JSON.stringify({ email, latitude, longitude, address }),
  });
}

// DELETE /user/delete/location?email=...
async function apiDeleteUserLocationByEmail(email) {
  const token = getAccessToken();
  const url = `${BASE_URL}/user/delete/location?email=${encodeURIComponent(email)}`;
  return fetchJson(url, {
    method: "DELETE",
    headers: { Authorization: `Bearer ${token}` },
  });
}

/* ===============================
   Kakao ÏßÄÎèÑ Î°úÎçî/Ïú†Ìã∏
   =============================== */
const KAKAO_APP_KEY = "084b4a076cd976847f592a5fea5ea24d";
const KAKAO_SDK_URL =
  `https://dapi.kakao.com/v2/maps/sdk.js?appkey=${KAKAO_APP_KEY}&autoload=false&libraries=services`;

const kakaoLoadError = { msg: null };

/** Kakao SDK Î°úÎçî (Ïã±Í∏ÄÌÜ§) */
function loadKakaoOnce(timeoutMs = 12000) {
  if (window.kakao?.maps) return Promise.resolve(window.kakao);
  if (window.__kakaoLoadPromise) return window.__kakaoLoadPromise;

  window.__kakaoLoadPromise = new Promise((resolve, reject) => {
    let timedOut = false;
    let retried = false;

    const done = () => {
      try {
        if (!window.kakao || !window.kakao.maps) {
          kakaoLoadError.msg = "kakao.maps ÎØ∏Ï¥àÍ∏∞Ìôî";
          return reject(new Error(kakaoLoadError.msg));
        }
        window.kakao.maps.load(() => {
          clearTimeout(timer);
          resolve(window.kakao);
        });
      } catch (err) {
        clearTimeout(timer);
        kakaoLoadError.msg = "kakao.maps.load Ï§ë ÏòàÏô∏";
        reject(err);
      }
    };

    const attachLoader = (scriptEl) => {
      const onReady = () => {
        if (timedOut) return;
        scriptEl.setAttribute("data-loaded", "1");
        done();
      };
      scriptEl.onload = onReady;
      scriptEl.onreadystatechange = () => {
        const rs = scriptEl.readyState;
        if (rs === "loaded" || rs === "complete") onReady();
      };
      scriptEl.onerror = (e) => {
        console.error("[Kakao SDK] load error:", scriptEl.src, e);
        if (timedOut) return;
        if (!retried) {
          retried = true;
          scriptEl.remove();
          const retry = document.createElement("script");
          retry.dataset.kakao = "sdk";
          retry.src = KAKAO_SDK_URL;
          retry.async = true;
          retry.type = "text/javascript";
          attachLoader(retry);
          document.head.appendChild(retry);
        } else {
          clearTimeout(timer);
          kakaoLoadError.msg = "ÏßÄÎèÑ SDK Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎìú Ïã§Ìå®";
          reject(e);
        }
      };
    };

    const timer = setTimeout(() => {
      timedOut = true;
      kakaoLoadError.msg = "ÏßÄÎèÑ SDK Î°úÎî© ÏãúÍ∞Ñ Ï¥àÍ≥º";
      reject(new Error(kakaoLoadError.msg));
    }, timeoutMs);

    let script = document.querySelector('script[data-kakao="sdk"]');
    if (!script) {
      script = document.createElement("script");
      script.dataset.kakao = "sdk";
      script.src = KAKAO_SDK_URL;
      script.async = true;
      script.type = "text/javascript";
      attachLoader(script);
      document.head.appendChild(script);
    } else {
      attachLoader(script);
      if (script.getAttribute("data-loaded") === "1" && window.kakao?.maps) {
        done();
      }
    }
  });

  return window.__kakaoLoadPromise;
}

/** CSS Î≥ÄÏàò --primary ÏùΩÍ∏∞ */
function getPrimaryHex() {
  const v = getComputedStyle(document.documentElement)
    .getPropertyValue("--primary")
    .trim();
  return v || "#5E936C";
}

/** ÌïÄ SVG dataURL */
function makePinDataUrl(hex) {
  const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="40" height="44" viewBox="0 0 40 44">
      <path d="M20 2C10.06 2 2 10.06 2 20.0c0 12.2 14.9 20.9 17.6 22.4a1.5 1.5 0 0 0 1.6 0C23.9 40.9 38 32.2 38 20.0 38 10.06 29.94 2 20 2z"
            fill="${hex}" stroke="white" stroke-width="2" />
      <circle cx="20" cy="20" r="5.5" fill="white"/>
      <circle cx="20" cy="20" r="3.5" fill="${hex}"/>
    </svg>`;
  return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
}

/** Î¨∏ÏûêÏó¥ Ï†ïÍ∑úÌôî */
function norm(s = "") {
  return s.replace(/\s+/g, " ").trim().toLowerCase();
}

/* ===============================
   üîß Í∏∞Î≥∏(Mock) Îèô & Ïõê Î∞òÍ≤Ω
   =============================== */
const DEFAULT_AREA = {
  name: "Ïã†Ï¥å",
  address: "ÏÑúÏö∏ ÏÑúÎåÄÎ¨∏Íµ¨ Ïã†Ï¥åÎèô",
  lat: 37.555,   // Ïã†Ï¥åÏó≠ Î∂ÄÍ∑º
  lng: 126.936,
  key: "sinchon_default",
};
const CIRCLE_RADIUS_M = 1000; // ‚úÖ 10km

/* ===============================
   Ïª¥Ìè¨ÎÑåÌä∏
   =============================== */
const LocationSettings = () => {
  const mapBoxRef = useRef(null);
  const mapRef = useRef(null);
  const geocoderRef = useRef(null);

  const myMarkerRef = useRef(null);
  const searchMarkerRef = useRef(null);
  const circlesRef = useRef([]); // 10km Ïõê Ïò§Î≤ÑÎ†àÏù¥Îì§

  const [loadingMap, setLoadingMap] = useState(false);
  const [loadError, setLoadError] = useState(null);

  const [query, setQuery] = useState("");
  const [suggests, setSuggests] = useState([]);
  const [showSuggests, setShowSuggests] = useState(false);
  const suggestBoxRef = useRef(null);

  const [selectedAreas, setSelectedAreas] = useState([]); // [{name,address,lat,lng,key}]
  const [pendingArea, setPendingArea] = useState(null);   // {name,address,lat,lng}

  const [saving, setSaving] = useState(false);
  const [deleting, setDeleting] = useState(false);
  const [loadingServerLoc, setLoadingServerLoc] = useState(false);

  const [mapHostReady, setMapHostReady] = useState(false);
  const setMapBoxEl = useCallback((el) => {
    mapBoxRef.current = el;
    setMapHostReady(!!el);
  }, []);

  // ÏßÄÎèÑ ÏÉùÏÑ±
  const ensureMap = useCallback(
    async (center) => {
      if (!mapHostReady) return null;
      if (mapRef.current) {
        if (center && window.kakao) {
          const ll = new window.kakao.maps.LatLng(center.lat, center.lng);
          mapRef.current.setCenter(ll);
          requestAnimationFrame(() => mapRef.current?.relayout());
        }
        return mapRef.current;
      }

      setLoadingMap(true);
      setLoadError(null);
      try {
        const kakao = await loadKakaoOnce();

        const box = mapBoxRef.current;
        if (!box) {
          setLoadingMap(false);
          return null;
        }

        if (box.getBoundingClientRect().height < 40) {
          box.style.minHeight = "420px";
          await new Promise((r) => requestAnimationFrame(r));
        }

        const map = new kakao.maps.Map(box, {
          center: new kakao.maps.LatLng(
            center?.lat ?? DEFAULT_AREA.lat,
            center?.lng ?? DEFAULT_AREA.lng
          ),
          level: 8, // üîé 10km ÏõêÏù¥ Î≥¥Ïù¥ÎèÑÎ°ù ÏÇ¥Ïßù Îçî Î©ÄÎ¶¨
        });
        mapRef.current = map;

        geocoderRef.current = new kakao.maps.services.Geocoder();

        kakao.maps.event.addListener(map, "click", (mouseEvent) => {
          const ll = mouseEvent.latLng;
          ensureSearchMarker(ll);
          reverseGeocodeToPending(ll.getLat(), ll.getLng());
          map.setCenter(ll);
        });

        requestAnimationFrame(() => map?.relayout());
        setLoadingMap(false);
        return map;
      } catch (e) {
        console.error("[ensureMap] Ïã§Ìå®:", e, kakaoLoadError.msg);
        setLoadError(kakaoLoadError.msg || "ÏßÄÎèÑ Î°úÎî© Ïã§Ìå®");
        setLoadingMap(false);
        return null;
      }
    },
    [mapHostReady]
  );

  // Ï¥àÍ∏∞Ìôî: ÏßÄÎèÑ ‚Üí ÏÑúÎ≤Ñ ÏúÑÏπò Î°úÎìú
  useEffect(() => {
    (async () => {
      if (!mapHostReady) return;
      await ensureMap();
      await loadServerLocationAndDraw();
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [mapHostReady]);

  /** Ï¢åÌëú ‚Üí Ï£ºÏÜåÎ°ú pendingArea Í∞±Ïã† */
  const reverseGeocodeToPending = (lat, lng) => {
    const kakao = window.kakao;
    if (!kakao || !geocoderRef.current) return;
    geocoderRef.current.coord2Address(lng, lat, (data, status) => {
      if (status === kakao.maps.services.Status.OK && data && data[0]) {
        const addr =
          data[0].road_address?.address_name ||
          data[0].address?.address_name ||
          "";
        const name =
          data[0].road_address?.region_3depth_name ||
          data[0].address?.region_3depth_name ||
          addr;
        setPendingArea({ name, address: addr, lat, lng });
      }
    });
  };

  /** Í≤ÄÏÉâ/ÌÅ¥Î¶≠Ïö© ÌïÄ ÎßàÏª§ */
  const ensureSearchMarker = (latLng) => {
    const kakao = window.kakao;
    if (!kakao || !mapRef.current) return;

    const primary = getPrimaryHex();
    const image = new kakao.maps.MarkerImage(
      makePinDataUrl(primary),
      new kakao.maps.Size(40, 44),
      { offset: new kakao.maps.Point(20, 44) }
    );

    if (!searchMarkerRef.current) {
      searchMarkerRef.current = new kakao.maps.Marker({
        position: latLng,
        image,
        draggable: true,
        zIndex: 10,
      });
      searchMarkerRef.current.setMap(mapRef.current);

      kakao.maps.event.addListener(searchMarkerRef.current, "dragend", () => {
        const pos = searchMarkerRef.current.getPosition();
        reverseGeocodeToPending(pos.getLat(), pos.getLng());
      });
    } else {
      searchMarkerRef.current.setImage(image);
      searchMarkerRef.current.setPosition(latLng);
    }
  };

  /** ÎÇ¥ ÏúÑÏπò (ÌååÎûÄ ÌéÑÏä§) */
  const getCurrent = () => {
    if (!navigator.geolocation) {
      alert("Î∏åÎùºÏö∞Ï†ÄÍ∞Ä ÏúÑÏπò Ï†ïÎ≥¥Î•º ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.");
      return;
    }
    navigator.geolocation.getCurrentPosition(
      async (pos) => {
        const p = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        const map = await ensureMap(p);
        if (!map || !window.kakao) return;

        const ll = new window.kakao.maps.LatLng(p.lat, p.lng);
        map.setCenter(ll);
        map.setLevel(8); // üîé 10km Î≥¥Í∏∞ Ï¢ãÍ≤å

        myMarkerRef.current?.setMap?.(null);
        const el = document.createElement("div");
        el.className = "mypos-marker";
        el.setAttribute("role", "img");
        el.setAttribute("aria-label", "ÎÇ¥ ÏúÑÏπò");
        el.innerHTML = `<span class="pulse"></span><span class="dot"></span>`;
        myMarkerRef.current = new window.kakao.maps.CustomOverlay({
          position: ll,
          content: el,
          xAnchor: 0.5,
          yAnchor: 0.5,
          zIndex: 99999,
          clickable: false,
        });
        myMarkerRef.current.setMap(map);

        requestAnimationFrame(() => map?.relayout());
      },
      () => alert("ÏúÑÏπò Í∂åÌïúÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî."),
      { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 }
    );
  };

  /** Í≤ÄÏÉâ */
  const searchDong = async (q) => {
    const kakao = await loadKakaoOnce().catch(() => null);
    if (!kakao?.maps?.services) return [];
    const places = new kakao.maps.services.Places();
    const geocoder = new kakao.maps.services.Geocoder();

    const results = await new Promise((resolve) => {
      places.keywordSearch(
        q,
        (data, status) =>
          resolve(status === kakao.maps.services.Status.OK ? data : []),
        { size: 10 }
      );
    });

    const candidates = results.map((r) => ({
      name: r.place_name,
      address: r.road_address_name || r.address_name,
      lat: parseFloat(r.y),
      lng: parseFloat(r.x),
    }));

    const extra = await new Promise((resolve) => {
      geocoder.addressSearch(q, (data, status) => {
        if (status === kakao.maps.services.Status.OK) {
          resolve(
            data.map((d) => ({
              name:
                d.address?.region_3depth_name ||
                d.road_address?.region_3depth_name ||
                d.address_name,
              address: d.address_name,
              lat: parseFloat(d.y),
              lng: parseFloat(d.x),
            }))
          );
        } else resolve([]);
      });
    });

    const merged = [...candidates, ...extra]
      .filter((x) => x.name)
      .reduce(
        (acc, cur) => {
          const key = `${cur.name}_${cur.address}_${cur.lat.toFixed(6)}_${cur.lng.toFixed(6)}`;
          if (!acc._set.has(key)) {
            acc._set.add(key);
            acc.list.push(cur);
          }
          return acc;
        },
        { _set: new Set(), list: [] }
      ).list
      .slice(0, 10);

    setSuggests(merged);
    setShowSuggests(true);
    return merged;
  };

  /** Ïõê ÌîÑÎ¶¨Î∑∞(10km) */
  const drawCircles = (areas) => {
    if (!window.kakao || !mapRef.current) return;
    const kakao = window.kakao;
    (circlesRef.current || []).forEach((c) => c.setMap(null));
    circlesRef.current = [];

    const primary = getPrimaryHex();
    areas.forEach((s) => {
      const circle = new kakao.maps.Circle({
        center: new kakao.maps.LatLng(s.lat, s.lng),
        radius: CIRCLE_RADIUS_M, // ‚úÖ 10km
        strokeWeight: 2,
        strokeColor: primary,
        strokeOpacity: 0.7,
        fillColor: primary,
        fillOpacity: 0.15,
      });
      circle.setMap(mapRef.current);
      circlesRef.current.push(circle);
    });
  };

  /** ÏÑúÎ≤Ñ Ï†ÄÏû• ÏúÑÏπò Î∂àÎü¨Ïò§Í∏∞ (ÏóÜÏúºÎ©¥ Ïã†Ï¥å Mock) */
  const loadServerLocationAndDraw = useCallback(async () => {
    const userId = getUserId();

    // Î°úÍ∑∏Ïù∏ ÏïàÌñàÍ±∞ÎÇò userId ÏóÜÏúºÎ©¥ Ïã†Ï¥å mock
    if (!userId) {
      setSelectedAreas([]);          // Ï†ÄÏû•Îêú Í±¥ ÏóÜÏùå
      setPendingArea(DEFAULT_AREA);  // Ïã†Ï¥åÏùÑ Í∏∞Î≥∏ ÌõÑÎ≥¥Î°ú
      const map = await ensureMap({ lat: DEFAULT_AREA.lat, lng: DEFAULT_AREA.lng });
      if (map) drawCircles([DEFAULT_AREA]); // Í∏∞Î≥∏ Ïõê Í∑∏Î†§Ï£ºÍ∏∞
      return;
    }

    setLoadingServerLoc(true);
    try {
      const data = await apiGetUserLocationById(userId);
      const lat = Number(data.latitude);
      const lng = Number(data.longitude);
      const address = data.address || "";
      const name = address;

      const area = { name, address, lat, lng, key: `${lat}_${lng}` };

      const map = await ensureMap({ lat, lng });
      if (map) drawCircles([area]);
      setSelectedAreas([area]);
      setPendingArea(area);
    } catch (e) {
      if (e.status === 404) {
        // ÏÑúÎ≤ÑÏóê Ï†ÄÏû•Í∞í ÏóÜÏúºÎ©¥ Ïã†Ï¥å mock
        setSelectedAreas([]);
        setPendingArea(DEFAULT_AREA);
        const map = await ensureMap({ lat: DEFAULT_AREA.lat, lng: DEFAULT_AREA.lng });
        if (map) drawCircles([DEFAULT_AREA]);
      } else {
        console.error("ÏÑúÎ≤Ñ ÏúÑÏπò Ï°∞Ìöå Ïã§Ìå®:", e);
      }
    } finally {
      setLoadingServerLoc(false);
    }
  }, [ensureMap]);

  /** Í≤ÄÏÉâ ÏÑ†ÌÉù ‚Üí Ïπ¥Î©îÎùº/ÌïÄ Ïù¥Îèô (ÎØ∏Î¶¨Î≥¥Í∏∞ ÌÖçÏä§Ìä∏Îßå) */
  const moveCameraTo = async (item) => {
    const kakao = await loadKakaoOnce().catch(() => null);
    const map = await ensureMap({ lat: item.lat, lng: item.lng });
    if (!map || !kakao) return;

    const ll = new kakao.maps.LatLng(item.lat, item.lng);
    map.setCenter(ll);
    map.setLevel(8); // üîé 10km

    ensureSearchMarker(ll);
    setPendingArea(item);
  };

  /** ‚ÄúÎÇ¥ ÎèôÎÑ§Î°ú ÏÑ§Ï†ï‚Äù ‚Äî ÏÑúÎ≤Ñ Ï†ÄÏû• ÏÑ±Í≥µ ÏãúÏóêÎßå UI Î∞òÏòÅ */
  const confirmPendingAsArea = async () => {
    if (!pendingArea) return;

    const addrKey = norm(pendingArea.address || pendingArea.name);
    const exists = selectedAreas.some(
      (s) => norm(s.address || s.name) === addrKey
    );
    if (exists) {
      alert("Ïù¥ÎØ∏ Í∞ôÏùÄ Ï£ºÏÜåÍ∞Ä Îì±Î°ùÎêòÏñ¥ ÏûàÏäµÎãàÎã§.");
      return;
    }

    const { email } = await ensureIdentity();
    if (!email) {
      alert("Î°úÍ∑∏Ïù∏ Ï†ïÎ≥¥Í∞Ä ÏóÜÏñ¥ ÏÑúÎ≤Ñ Ï†ÄÏû•ÏùÑ Í±¥ÎÑàÎúÅÎãàÎã§. (userEmail ÏóÜÏùå)");
      return;
    }

    setSaving(true);
    try {
      await apiSaveUserLocation({
        email,
        latitude: pendingArea.lat,
        longitude: pendingArea.lng,
        address: pendingArea.address || pendingArea.name,
      });

      await loadServerLocationAndDraw(); // ÏÑ±Í≥µ ÌõÑ ÏÑúÎ≤Ñ ÏÉÅÌÉú Í∏∞Ï§ÄÏúºÎ°ú Ïõê Îã§Ïãú Í∑∏Î¶º
      alert("ÏÑúÎ≤ÑÏóê ÎèôÎÑ§Í∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.");
    } catch (e) {
      console.error("ÏÑúÎ≤Ñ Ï†ÄÏû• Ïã§Ìå®:", e);
      alert(`ÏÑúÎ≤Ñ Ï†ÄÏû• Ïã§Ìå®: ${e.message}`);
    } finally {
      setSaving(false);
    }
  };

  /** ÌÉúÍ∑∏ ÌÅ¥Î¶≠ ‚Üí ÌôïÏù∏ ‚Üí ÏÑúÎ≤Ñ ÏÇ≠Ï†ú ÏÑ±Í≥µ Ïãú UI Í∞±Ïã† (Îã®Ïùº Ï†ÄÏû• Ï†ïÏ±Ö) */
  const handleTagDelete = async () => {
    const email = getEmail();
    if (!email) {
      alert("Î°úÍ∑∏Ïù∏ ÌõÑ ÏÇ≠Ï†úÌï† Ïàò ÏûàÏäµÎãàÎã§.");
      return;
    }
    const ok = window.confirm("ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?");
    if (!ok) return;

    setDeleting(true);
    try {
      await apiDeleteUserLocationByEmail(email);
      setSelectedAreas([]);
      drawCircles([]);
      setPendingArea(DEFAULT_AREA); // ÏÇ≠Ï†ú ÌõÑÏóî Îã§Ïãú Ïã†Ï¥å mock
      const map = await ensureMap({ lat: DEFAULT_AREA.lat, lng: DEFAULT_AREA.lng });
      if (map) drawCircles([DEFAULT_AREA]);
      alert("ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§");
    } catch (e) {
      console.error("ÏÇ≠Ï†ú Ïã§Ìå®:", e);
      alert(`ÏÇ≠Ï†ú Ïã§Ìå®: ${e.message}`);
    } finally {
      setDeleting(false);
    }
  };

  /** Ï∂îÏ≤ú ÏÉÅÏûê Ïô∏Î∂Ä ÌÅ¥Î¶≠ Îã´Í∏∞ */
  useEffect(() => {
    const onDown = (e) => {
      if (!suggestBoxRef.current) return;
      if (!suggestBoxRef.current.contains(e.target)) setShowSuggests(false);
    };
    if (showSuggests) document.addEventListener("pointerdown", onDown);
    return () => document.removeEventListener("pointerdown", onDown);
  }, [showSuggests]);

  const hasPending = !!pendingArea;

  return (
    <Layout pageTitle="ÏúÑÏπò ÏÑ§Ï†ï" activeMenuItem="location">
      <div className="location-page container">
        {/* ÏßÄÎèÑ */}
        <div className="map-wrap">
          {loadingMap ? (
            <div className="map-skeleton">ÏßÄÎèÑÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë‚Ä¶</div>
          ) : loadError ? (
            <div className="map-error">{String(loadError)}</div>
          ) : (
            <div
              ref={setMapBoxEl}
              className="mapbox"
              aria-label="ÏßÄÎèÑ"
              style={{ minHeight: 420 }}
            />
          )}

          {/* Ïö∞ÏÉÅÎã®: ÎÇ¥ ÏúÑÏπò */}
          {!loadError && (
            <div className="map-ctrl top-right">
              <button className="pill-btn" onClick={getCurrent}>
                ÎÇ¥ ÏúÑÏπò
              </button>
            </div>
          )}

          {/* Ï¢åÏÉÅÎã®: ÏÑúÎ≤Ñ ÎèôÍ∏∞Ìôî ÏÉÅÌÉú */}
          {!loadError && (
            <div className="map-ctrl top-left">
              <div className="sync-indicator" aria-live="polite">
                {loadingServerLoc
                  ? "ÏÑúÎ≤Ñ ÏúÑÏπò Î∂àÎü¨Ïò§Îäî Ï§ë‚Ä¶"
                  : deleting
                  ? "ÏÇ≠Ï†ú Ï§ë‚Ä¶"
                  : saving
                  ? "Ï†ÄÏû• Ï§ë‚Ä¶"
                  : ""}
              </div>
            </div>
          )}

          {/* ÌïòÎã® Í∞ÄÏö¥Îç∞: ÏÑ†ÌÉù ÎØ∏Î¶¨Î≥¥Í∏∞ Ïπ© */}
          {hasPending && !loadError && (
            <div className="pending-chip bottom-center" aria-live="polite">
              <div className="pc-name">{pendingArea.name}</div>
              <div className="pc-addr">{pendingArea.address}</div>
            </div>
          )}

          {/* Ïö∞ÌïòÎã®: ÎÇ¥ ÎèôÎÑ§Î°ú ÏÑ§Ï†ï */}
          {hasPending && !loadError && (
            <button
              className="fab br"
              onClick={confirmPendingAsArea}
              aria-label="ÎÇ¥ ÎèôÎÑ§Î°ú ÏÑ§Ï†ï"
              disabled={saving}
            >
              {saving ? "Ï†ÄÏû• Ï§ë..." : "ÎÇ¥ ÎèôÎÑ§Î°ú ÏÑ§Ï†ï"}
            </button>
          )}
        </div>

        {/* Í≤ÄÏÉâ & ÎÇ¥ ÎèôÎÑ§ Ïπ¥Îìú */}
        <div className="panel">
          <div className="search-wrap" ref={suggestBoxRef}>
            <label htmlFor="dong-input" className="sr-only">
              Îèô/Ï£ºÏÜå/Í±¥Î¨º Í≤ÄÏÉâ
            </label>
            <div className="search-row" role="group" aria-label="Í≤ÄÏÉâ Ìèº">
              <input
                id="dong-input"
                name="dong"
                className="input"
                placeholder="Îèô/Ï£ºÏÜå/Í±¥Î¨ºÎ°ú Í≤ÄÏÉâ (Ïòà: Í∞ÅÏÇ∞Îèô, Ïä§ÌÉÄÎ≤ÖÏä§ Ïã†ÏÇ¨)"
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                onKeyDown={async (e) => {
                  if (e.key === "Enter" && query.trim()) {
                    const list = await searchDong(query.trim());
                    if (list.length) setShowSuggests(true);
                  }
                }}
                onFocus={() => {
                  if (suggests.length) setShowSuggests(true);
                }}
                autoComplete="address-level3"
                inputMode="search"
              />
              <button
                className="btn"
                type="button"
                onClick={async () => {
                  if (!query.trim()) return;
                  const list = await searchDong(query.trim());
                  if (list.length) setShowSuggests(true);
                }}
              >
                Í≤ÄÏÉâ
              </button>
            </div>

            {showSuggests && suggests.length > 0 && (
              <div className="suggest-box" role="listbox" aria-label="Í≤ÄÏÉâ Í≤∞Í≥º">
                {suggests.map((s, i) => (
                  <button
                    key={`${s.name}_${s.lat}_${s.lng}_${i}`}
                    className="suggest-item"
                    role="option"
                    onClick={() => {
                      setQuery(s.name);
                      setShowSuggests(false);
                      moveCameraTo(s);
                    }}
                  >
                    <div className="s-name">{s.name}</div>
                    <div className="s-addr">{s.address}</div>
                  </button>
                ))}
              </div>
            )}
          </div>

          <div className="areas-wrap">
            <div className="areas-head">
              <strong>ÎÇ¥ ÎèôÎÑ§ (Îã®Ïùº)</strong>
              <span className="areas-hint">ÌÉúÍ∑∏ ÌÅ¥Î¶≠ Ïãú ÏÇ≠Ï†ú</span>
            </div>
            <ul className="taglist" role="list">
              {selectedAreas.map((s) => (
                <li key={s.key}>
                  <button
                    type="button"
                    className="tag chip"
                    title="ÌÅ¥Î¶≠ÌïòÎ©¥ ÏÇ≠Ï†ú"
                    onClick={handleTagDelete}
                    onKeyDown={(e) => {
                      if (e.key === "Enter" || e.key === " ") {
                        e.preventDefault();
                        handleTagDelete();
                      }
                    }}
                  >
                    <div className="chip-main">
                      <span className="tag-name">{s.name}</span>
                      <span className="tag-addr">{s.address}</span>
                    </div>
                    <span className="chip-del" aria-hidden>
                      ÏÇ≠Ï†ú
                    </span>
                  </button>
                </li>
              ))}
              {selectedAreas.length === 0 && (
                <li className="empty">ÏïÑÏßÅ ÏÑ§Ï†ïÎêú ÎèôÎÑ§Í∞Ä ÏóÜÏäµÎãàÎã§.</li>
              )}
            </ul>
          </div>
        </div>
      </div>

      <BottomBar />
    </Layout>
  );
};

export default LocationSettings;
